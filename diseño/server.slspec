TAD Nombre es string

TAD servidor:

    generos:
        server

    exporta:
        observadores, generadores, verMapa, verCasas, verComercios, verPopularidad y verTurno

    usa:
        SimCity, Mapa, Nombre, Pos, Construccion, Nivel, Nat, bool, dicc(α, β), secu(α)

    igualdad:
        (∀ s1, s2: server)(s1 =obs s2 ⟺ (
            partidas(s1) =obs partidas(s2) ∧ congeladas(s1) =obs congeladas(s2)
        )

    observadores:
        partidas: server ➝ dicc(Nombre, SimCity)
        congeladas: server ➝ secu(Nombre)

    generadores:
        nuevoServer: ➝ server

        nuevaPartida: server s × Nombre p × Mapa ➝ server                          
            {¬def?(p, partidas(s))}
        
        avanzarTurnoPartida: server s × Nombre p × dicc(Pos, Construccion) cs ➝ server    
            {   def?(p, partidas(s)) ∧  // existe
                p ∉ congeladas(s) ∧     // se puede modificar
                ¬vacia?(claves(cs)) ∧L  // se agrega al menos una construcción en el turno
                (∀ pos: Pos)(pos ∈ claves(cs) ⟹L    // no se agrega nada sobre un rio y la posicion está libre
                    ¬sobreRio(pos, mapa(sim)) ∧
                    ¬def?(pos, casas(sim)) ∧
                    ¬def?(pos, comercios(sim))
                )
            } donde sim ≡ obtener(p, partidas(s))
        
        unirPartidas: server s × Nombre p1 × Nombre p2 ➝ server                            
            {   def?(p1, partidas(s)) ∧ // existe p1
                def?(p2, partidas(s)) ∧ // existe p2
                p1 ∉ congeladas(s) ∧    // se puede modificar p1
                p2 ∉ congeladas(s) ∧L   // se puede modificar p2
                (∀ pos: Pos)(pos ∈ claves(construcciones1) ⟹L   
                    ¬sobreRio(pos, sim2) ∧  // las construcciones de sim1 no estan sobre rios de sim2
                    ((∄otra: Pos)(otra ∈ construcciones1 ∧L 
                        obtener(pos, construcciones1).nivel < obtener(otra, construcciones1).nivel
                    ) ⟹L ¬def?(pos, construcciones2)) // las construcciones de maximo nivel de sim1 no estan ocupadas en sim2
                ) ∧
                (∀ pos: Pos)(pos ∈ claves(construcciones2) ⟹L   
                    ¬sobreRio(pos, sim1) ∧  // las construcciones de sim2 no estan sobre rios de sim1
                    ((∄otra: Pos)(otra ∈ construcciones2 ∧L 
                        obtener(pos, construcciones2).nivel < obtener(otra, construcciones2).nivel
                    ) ⟹L ¬def?(pos, construcciones1)) // las construcciones de maximo nivel de sim2 no estan ocupadas en sim1
                )                 
            } donde sim1 ≡ obtener(p1, partidas(s)), 
                    sim2 ≡ obtener(p2, partidas(s)), 
                    construcciones1 ≡ casas(sim1) ⋃ comercios(sim1), 
                    construcciones2 ≡ casas(sim2) ⋃ comercios(sim2)

    otras operaciones:
        verMapa: server s × Nombre p ➝ Mapa                    {def?(p, partidas(s))}  
        verCasas: server s × Nombre p ➝ dicc(Pos, Nivel)       {def?(p, partidas(s))}
        verComercios: server s × Nombre p ➝ dicc(Pos, Nivel)   {def?(p, partidas(s))}
        verPopularidad: server s × Nombre p ➝ Nat              {def?(p, partidas(s))}
        verTurno: server s × Nombre p ➝ Nat                    {def?(p, partidas(s))}
        // privadas
        ∎ ⋃ ∎: dicc(α, β) × dicc(α, β) ➝ dicc(α, β)
        _definir: dicc(α, β) × dicc(α, β) × conj(α) ➝ dicc(α, β)
        
    axiomas:
        (∀ s: server, p, p1, p2: Nombre, m: Mapa, cs: conj(Pos), a, b: dicc(Pos, Nivel))

        partidas(nuevoServer) ≡ vacio
        partidas(nuevaPartida(s, p, m)) ≡ definir(p, iniciar(m), partidas(s))
        partidas(avanzarTurnoPartida(s, p, cs)) ≡ definir(p, avanzarTurno(obtener(p, partidas(s)), cs), partidas(s))
        partidas(unirPartidas(s, p1, p2)) ≡ definir(p1, unir(obtener(p1, partidas(s)), obtener(p2, partidas(s))), partidas(s))

        congeladas(nuevaPartida) ≡ <>
        congeladas(nuevaPartida(s, p, m)) ≡ congeladas(s)
        congeladas(avanzarTurnoPartida(s, p, cs)) ≡ congeladas(s)
        congeladas(unirPartidas(s, p1, p2)) ≡ p2 • congeladas(s)  

        verMapa(s, p) ≡ mapa(obtener(p, partidas(s)))
        verCasas(s, p) ≡ casas(obtener(p, partidas(s)))
        verComercios(s, p) ≡ comercios(obtener(p, partidas(s)))
        verPopularidad(s, p) ≡ popularidad(obtener(p, partidas(s)))
        verTurno(s, p) ≡ turnos(obtener(p, partidas(s)))

        // privadas
        a ⋃ b ≡ _definir(a, b, claves(b))
        _definir(a, b, cs) ≡ if vacio?(cs) then a else _definir(definir(dameUno(cs), obtener(dameUno(cs), b)), b, sinUno(cs)) fi
        
fin TAD
