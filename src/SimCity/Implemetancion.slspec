//hline----------------------------------------
bbb{iniciar}(in m: Mapa) ⟶ res : estr
    estr.turno ← 0
    estr.popularidad ← 0
    estr.mapa ← m
    estr.casas ← vacio()
    estr.comercios ← vacio()
    estr.uniones ← vacia()
    return estr
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{avanzarTurno}(inout SimCity s,  in dicc(Pos, Construccion) cs)
    // actualizo turno de las uniones 
    for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
        turnoDesdeUnion ← turnoDesdeUnion + 1;

    // subo 1 al nivel de cada una de las casas del simcity s 
    itDicc(Pos, Nivel) itCasas ← crearIt(s.casas);
    while(haySiguiente(itCasas)) :
        siguienteSignificado(itCasas) ← siguienteSignificado(itCasas) + 1
        avanzar(itCasas)

    // subo 1 al nivel de cada una de los comercios del simcity s 
    itDicc(Pos, Nivel) itComercios ← crearIt(s.comercios);
    while(haySiguiente(itComercios)) :
        siguienteSignificado(itComercios) ← siguienteSignificado(itComercios) + 1
        avanzar(itComercios)

    // agrego con nivel 1 cada una de las casas o comercios agregados en el turno
    itDicc(Pos, Nivel) itCs ← crearIt(cs);
    while(haySiguiente(itCs)) :
        if(siguienteSignificado(itCs) =obs "casa") :
            agCasa(s.casas, siguienteClave(itCs), 1)
        else if(siguienteSignificado(itCs) =obs "comercio") :
            agComercio(s.comercio, siguienteClave(itCs), 1)
        avanzar(itCs)

    estr.turno ⟵ estr.turno + 1 // actualizo el turno
Complejidad: O(long(s.uniones) + #claves(s.casas) + #claves(s.comercios) + #claves(cs))
//hline----------------------------------------

//hline----------------------------------------
bbb{unir}(inout SimCity s1,  inout Simcity s2)
    s1.popularidad ← s1.popularidad + s2.popularidad + 1
    turno ← max(s1.turno, s2.turno)
    hijo nuevoHijo ← <direccion(s2), 0>
    agregarAtras(s1.uniones, nuevoHijo)
Complejidad: O(1)
//hline----------------------------------------

Asumo que existe un conjunto U ≡ {u₁, u₂, ... , uₙ}
tal que cada uno de esos Uᵢ son los simcities que componen al simcity original
llamamos nodos : #U
llamamos sumCasas : ⅀_{i=1, nodos}^{copiar(uᵢ.casas)}
llamamos sumComercios : ⅀_{i=1, nodos}^{copiar(uᵢ.comercios)}
llamamos sumMapas : ⅀_{i=1, nodos}^{uᵢ.mapa}
//hline----------------------------------------
bbb{mapa}(in SimCity s) ➝ res : Mapa 
    Mapa res ← s.mapa
    for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
        res ← res + bbb{mapa}(s.uniones[i].sc*)
    return res
Complejidad: O(sumMapas) 
cabe aclarar que la suma de los mapas esta definida
//hline----------------------------------------

//hline--------------------------------------
bbb{casas}(in SimCity s) ➝ res : dicc(Pos, Nivel)
    dicc res ← copiar(s.casas)
    dicc comerciosTotales ← copiar(s.comercios)
    for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
        itDicc(Pos, Nivel) itCs ← crearIt(bbb{casas}(s.uniones[i].sc*));
        while(haySiguiente(itCs)) :
            Pos p ← siguienteClave(itCs)
            Nivel n ← siguienteSignificado(itCs)
            if(¬def?(res, p) ∧ ¬def?(comerciosTotales, p)) :
                definir(res, p, n + s.uniones[i].turnosDesdeUnion)
            avanzar(itCs)
        comerciosTotales ← comerciosTotales ⋃ s.uniones[i].sc->comercios
    return res
Complejidad: O([sumComercios + sumCasas]² + nodos)
//hline----------------------------------------
//O(sumComercios² + sumCasas² + sumComercios * sumCasas + nodos)

//hline----------------------------------------
bbb{comercios}(in SimCity s) ➝ res : dicc(Pos, Nivel)
1:  return comerciosAux(s, casas(s), 0)
Complejidad: O(casas(s))

bbb{comerciosAux}(in SimCity s, in casasTotales dicc(Pos, Nivel), in Nat tdu) ➝ res : dicc(Pos, Nivel)
1:  dicc res ← vacio()
2:  itDicc(Pos, Nivel) itCs ← crearIt(s.comercios);
3:  while(haySiguiente(itCs)) :
4:      Pos p ← siguienteClave(itCs)
5:      Nivel n ← siguienteSignificado(itCs)
6:      Nivel m ← max(n + tdu, nivelCom(p, casasTotales))
7:      definir(res, p, m)
8:      avanzar(itCs)
9:  for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
10:     tdu ← s.uniones[i].turnosDesdeUnion
11:     itDicc(Pos, Nivel) itCs ← crearIt(bbb{comerciosAux}(s.uniones[i].sc*, casasTotales, tdu));
12:     while(haySiguiente(itCs)) :
13:         Pos p ← siguienteClave(itCs)
14:         Nivel n ← siguienteSignificado(itCs)
15:         if(¬def?(res, p) ∧ ¬def?(casasTotales, p)) :
16:             definir(res, p, n)
17:         avanzar(itCs)
18: return res
Complejidad: O(sumComercios*sumCasas + sumComercios² + nodos)
//hline----------------------------------------

//hline----------------------------------------
bbb{popularidad}(in SimCity s) ➝ res : Nat
1:  return s.popularidad
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{nivelCom}(in Pos p, in dicc(pos, Nivel) cs) ➝ Nat
1:  nat maxLvl ← 1
2:  for(int i = -3; i <= 3; ++i) :
3:      for(int j = |i|-3; j <= 3-|i|; ++j) :
4:          if(p.x + i >= 0 ∧ p.y + j >= 0) :
5:              Pos p2 ← <p.x+i, p.y+j> 
6:              if(def?(cs, p2)) :
7:                  maxLvl = max(maxLvl, obtener(cs, p2))
8:  return maxLvl
Complejidad: O(#claves(cs))
//hline----------------------------------------

//hline----------------------------------------
bbb{agCasa}(inout dicc(Pos, Nivel) casas, in Pos p, in Nivel n) :
1:  definirRapido(casas, p, n)
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{agComercio}(inout dicc(Pos, Nivel) comercios, in Pos p, in Nivel n) :
1:  definirRapido(comercio, p, n)
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{turnos}(in SimCity s) ➝ res : Nat
1:  return s.turno
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
• ⋃ •(in dicc(α, β) d1, in dicc(α, β) d2) ➝ res : dicc(α, β)
1:  dicc(α, β) res = copiar(d1)
2:  itDicc(α, β) itCs ← crearIt(d2);
3:  while(haySiguiente(itCs)) :
4:      α a ← siguienteClave(itCs)
5:      β b ← siguienteSignificado(itCs)
6:      if(¬def?(res, a)) :
7:          definir(res, a, b)
8:      avanzar(itCs)
9:  return res
Complejidad: O(copy(d1) + #claves(d2))
//hline----------------------------------------

//hline----------------------------------------
bbb{construcc}(in SimCity s) ➝ res : Nat
1:  return bbb{casas}(s) ⋃ bbb{comercios}(s)
Complejidad: O(bbb{casas}(d1) + bbb{comercios}(d2))
//hline----------------------------------------



