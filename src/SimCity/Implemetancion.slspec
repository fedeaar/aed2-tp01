//hline----------------------------------------
bbb{iniciar}(in m: Mapa) ⟶ res : estr
    estr.turno ← 0
    estr.popularidad ← 0
    estr.mapa ← m
    estr.casas ← vacio()
    estr.comercios ← vacio()
    estr.uniones ← vacia()
    return estr
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{avanzarTurno}(inout SimCity s,  in dicc(Pos, Construccion) cs)
    // actualizo turno de las uniones 
    for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
        turnoDesdeUnion ← turnoDesdeUnion + 1;

    // subo 1 al nivel de cada una de las casas del simcity s 
    itDicc(Pos, Nivel) itCasas ← crearIt(s.casas);
    while(haySiguiente(itCasas)) :
        siguienteSignificado(itCasas) ← siguienteSignificado(itCasas) + 1
        avanzar(itCasas)

    // subo 1 al nivel de cada una de los comercios del simcity s 
    itDicc(Pos, Nivel) itComercios ← crearIt(s.comercios);
    while(haySiguiente(itComercios)) :
        siguienteSignificado(itComercios) ← siguienteSignificado(itComercios) + 1
        avanzar(itComercios)

    // agrego con nivel 1 cada una de las casas o comercios agregados en el turno
    itDicc(Pos, Nivel) itCs ← crearIt(cs);
    while(haySiguiente(itCs)) :
        if(siguienteSignificado(itCs) =obs "casa") :
            agCasa(s.casas, siguienteClave(itCs), 1)
        else if(siguienteSignificado(itCs) =obs "comercio") :
            agComercio(s.comercio, siguienteClave(itCs), 1)
        avanzar(itCs)

    estr.turno ⟵ estr.turno + 1 // actualizo el turno
Complejidad: O(long(s.uniones) + #claves(s.casas) + #claves(s.comercios) + #claves(cs))
//hline----------------------------------------

//hline----------------------------------------
bbb{unir}(inout SimCity s1,  inout Simcity s2)
    s1.popularidad ← s1.popularidad + s2.popularidad + 1
    turno ← max(s1.turno, s2.turno)
    hijo nuevoHijo ← <direccion(s2), 0>
    agregarAtras(s1.uniones, nuevoHijo)
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{mapa}(in SimCity s) ➝ res : Mapa 
    Mapa res ← s.mapa
    for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
        res ← res + bbb{mapa}(s.uniones[i].sc*)
    return res
Complejidad: O()
//hline----------------------------------------

//hline--------------------------------------
bbb{casas}(in SimCity s) ➝ res : dicc(Pos, Nivel)
    dicc res ← copiar(s.casas)
    for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
        itDicc(Pos, Nivel) itCs ← crearIt(bbb{casas}(s.uniones[i].sc*));
        while(haySiguiente(itCs)) :
            Pos p ← siguienteClave(itCs)
            Nivel n ← siguienteSignificado(itCs)
            if(¬def?(res, p) ∧ ¬def?(s.casas, p)) :
                definir(res, p, n + s.uniones[i].turnosDesdeUnion)
            avanzar(itCs)
    return res
//hline----------------------------------------

//hline----------------------------------------
bbb{comercios}(in SimCity s) ➝ res : dicc(Pos, Nivel)
    return comerciosAux(s, casas(s))

bbb{comerciosAux}(in SimCity s, in casasTotales dicc(Pos, Nivel)) ➝ res : dicc(Pos, Nivel)
    dicc res ← copiar(s.comercios)
    itDicc(Pos, Nivel) itCs ← crearIt(bbb{comerciosAux}(s.uniones[i].sc*, casastotales));
    while(haySiguiente(itCs)) :
        Pos p ← siguienteClave(itCs)
        Nivel n ← siguienteSignificado(itCs)
        if(¬def?(res, p) ∧ ¬def?(s.casas, p)) :
            Nivel m ← max(n + s.uniones[i].turnosDesdeUnion, nivelCom(p, casasTotales(s)))
            definir(res, p, m)
        avanzar(itCs)

    for(nat i ← 0; i < long(s.uniones); i ← i + 1) : 
        itDicc(Pos, Nivel) itCs ← crearIt(bbb{comerciosAux}(s.uniones[i].sc*, casastotales));
        while(haySiguiente(itCs)) :
            Pos p ← siguienteClave(itCs)
            Nivel n ← siguienteSignificado(itCs)
            if(¬def?(res, p) ∧ ¬def?(s.casas, p)) :
                Nivel m ← max(n + s.uniones[i].turnosDesdeUnion, nivelCom(p, casasTotales(s)))
                definir(res, p, m)
            avanzar(itCs)
    return res
//hline----------------------------------------

//hline----------------------------------------
bbb{popularidad}(in SimCity s) ➝ res : Nat
    return s.popularidad
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{nivelCom}(in Pos p, in dicc(pos, Nivel) casas) ➝ Nat
    nat maxLvl ← 1
    for(int i = -3; i <= 3; ++i) :
        for(int j = |i|-3; j <= 3-|i|; ++j) :
            if(p.x + i >= 0 ∧ p.y + j >= 0) :
                Pos p2 ← <p.x+i, p.y+j> 
                if(def?(casas, p2)) :
                    maxLvl = max(maxLvl, obtener(casas, p2))
    return maxLvl
//hline----------------------------------------

//hline----------------------------------------
bbb{agCasa}(inout dicc(Pos, Nivel) casas, in Pos p, in Nivel n) :
    definirRapido(casas, p, n)
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{agComercio}(inout dicc(Pos, Nivel) comercios, in Pos p, in Nivel n) :
    definirRapido(comercio, p, n)
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
bbb{turnos}(in SimCity s) ➝ res : Nat
    return s.turno
Complejidad: O(1)
//hline----------------------------------------

//hline----------------------------------------
• ⋃ •(in dicc(α, β) d1, in dicc(α, β) d2) ➝ res : dicc(α, β)
    dicc(α, β) res = copiar(d1)
    itDicc(α, β) itCs ← crearIt(d2);
    while(haySiguiente(itCs)) :
        α a ← siguienteClave(itCs)
        β b ← siguienteSignificado(itCs)
        if(¬def?(res, a)) :
            definir(res, a, b)
        avanzar(itCs)
    return res
Complejidad: O(copy(d1) + #claves(d2))
//hline----------------------------------------

//hline----------------------------------------
bbb{construcc}(in SimCity s) ➝ res : Nat
    return bbb{casas}(s) ⋃ bbb{comercios}(s)
Complejidad: O(bbb{casas}(d1) + bbb{comercios}(d2))
//hline----------------------------------------



