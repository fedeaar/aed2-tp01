representacion SimCity:

    simCity src estr donde:
        estr ≡ Tupla< 
            turno: Nat, 
            popularidad: Nat,       
            mapa: Mapa,
            casas: diccLineal(pos, Nivel), 
            comercios: diccLineal(pos, NivelBase),
            uniones: lista(hijo)
        >
        hijo ≡ tupla<
            sc: puntero(estr),
            turnosDesdeUnion: nat  
        >
        Pos ≡ tupla<x: Nat, y: Nat>

    invariante:
        rep: ^estr ➝ boolean
        (∀ e: ^estr)
        rep(e) ≡
            &e ∉ conjUnidos ∧L // la estructura no loopea a sí misma 
            (∀ p: puntero(^estr))(p ∈ conjUnidos ⟹L
                e.turno ≥ (*p).turno // el turno actual es mayor o igual al turno de cualquier simCity hijo
            ) ∧
            e.popularidad = #(conjUnidos) ∧L // la popularidad es igual a la cantidad de uniones
            (∀p: pos)(pos ∈ claves(conjCasas) ⟹L
                obtener(pos, conjCasas) < e.turno  ∧ // el turno es mas grande que el nivel de cualquier casa
                ¬def(pos, e.comercios) ∧  // ningun comercio de este sc está en esta posicion
                ¬esRio(pos, conjMapas) // ninguna casa esta sobre un río 
            ) ∧
            (∀p: pos)(pos ∈ claves(conjComercios) ⟹L
                obtener(pos, conjComercios) < e.turno  ∧ // el turno es mas grande que el nivel base de cualquier comercio
                ¬def(pos, e.casas) ∧  // ninguna casa de este simcity está en esta posicion
                ¬esRio(pos, conjMapas) // ningun comercio está sobre un río 
            ) ∧
            (∀ n: Nat)(0 ≤ n < e.turno ⟹L  // se agregó al menos una consrucción cada turno hasta el actual
                (∃p: pos)(def?(p, conjCasas) ∧L
                    obtener(pos, conjCasas) = n 
                ) ∨ 
                (∃p: pos)(def?(p, conjComercios) ∧L
                    obtener(pos, comercios) = n 
                )
            ) ∧ 
            (∀ h: hijo)(esta?(h, e.uniones) ⟹L
                h.simCity ≠ null ∧L // los punteros son validos
                h.sc ∉ unirPunteros(remover(p, e.uniones)) ∧ // y no loopean a ningun otro hijo, ni sus descendientes
                rep(*(h.simCity)) ∧L // la representación del hijo es válida
                e.turno ≥ h.turnosDesdeUnion ∧  // el turno es >= a la cantidad de turnos desde la union
                (∀ h2: hijo)(esta?(h2, e.uniones) ∧L pos(h2, e.uniones) > pos(h, e.uniones) ⟹L
                    h2.turnosDesdeUnion ≤ h.turnosDesdeUnion // las uniones van de más antiguas a más recientes
                )
            ) ∧
            unionesValidas(e, e.uniones)
            // no se solapan posiciones maximas entre la estructura hasta el hijo 'x' y ese hijo, para todo hijo
            // descontando las casas y comercios agregados despues de la union  

            donde:
                conjUnidos ≡ unirPunteros(e.uniones)
                conjCasas ≡ unirCasas(ag(&e, conjUnidos)) 
                conjComercios ≡ unirComercios(ag(&e, conjUnidos))
                conjMapas  ≡ unirMapas(ag(&e, conjUnidos))

        unirPunteros: secu(hijo) ➝ conj(puntero(^estr))
        unirPunteros(s) ≡ _unirPunteros(s, ∅)

        _unirPunteros: secu(hijo) × conj(puntero(^estr)) ➝ conj(puntero(^estr))
        _unirPunteros(sh, ps) ≡ 
            if vacia?(sh) then                 
                ps
            else if prim(sh).simCity = null ∨L prim(sh).sc ∈ ps /* loop! */ then 
                _unirPunteros(fin(sh), ps)
            else 
                _unirPunteros(prim(sh).sc->uniones, Ag(prim(sh).sc, ps)) ⋃ 
                    _unirPunteros(fin(sh), Ag(prim(sh).sc, ps)) // ag se encarga de posibles duplicados en la union
            fi

        unirMapas: conj(puntero(^estr)) ➝ Mapa
        unirMapas(ps) ≡ if vacio?(ps) then crear(∅, ∅) else dameUno(ps)->mapa + UnirMapas(sinUno(ps)) fi

        unirCasas: conj(puntero(^estr)) ➝ dicc(Pos, Nivel)
        unirCasas(ps) ≡ if vacio?(ps) then vacio else p->casas ⋃ unirCasas(sinUno(ps)) fi

        unirComercios: conj(puntero(^estr)) ➝ dicc(Pos, Nat)
        unirComercios(ps) ≡ if vacio?(ps) then vacio else p->comercios ⋃ unirComercios(sinUno(ps)) fi

        remover: secu(α) × α ➝ secu(α) // remueve la primera aparicion
        remover(s, a) ≡ if vacia?(s) then <> else if a = prim(s) then fin(s) else prim(s) • remover(fin(s), a) fi
        
        unionesValidas: ^estr × secu(hijo) ➝ bool
        unionesValidas(e, s) ≡ vacio?(s) ∨L (maxcons(e, izq) ⋂ maxcons(e, der) = ∅ ∧ unionesValidas(e, com(s)))
            donde:
                com ≡ unirPunteros(com(e.uniones))
                ult ≡ ult(e.uniones) • <>
                casascom ≡ unirCasas(com) ⋃ filtrar(e.casas, ult(s).turnosDesdeUnion) 
                comercom ≡ unirComercios(com) ⋃ filtrar(e.comercios, ult(s).turnosDesdeUnion)
                casasult ≡ unirCasas(ult)
                comerult ≡ unirComercios(ult)
                izq ≡ claves(casascom) ⋃ claves(comercom)
                der ≡ claves(casasult) ⋃ claves(comerult)

        filtrar: dicc(Pos, Nat) × Nat ➝ dicc(Pos, Nat)
        filtrar(d, n) ≡ 
            if vacio?(d) then 
                vacio 
            else if sig ≤ n then // las nuevas cons dsp de una union son las de un nivel base < a los turnos desde la union
                filtrar(borrar(clave, d), n) 
            else 
                definir(clave, sig, filtrar(borrar(clave, d), n)) 
            fi
            donde:
                clave ≡ dameUno(claves(d))
                sig ≡ obtener(clave, d)

        maxcons: ^estr × conj(Pos) ➝ conj(Pos)
        maxcons(e, c) ≡ _maxcons(e, c, ∅, 0)

        _maxcons: ^estr × conj(Pos) × conj(Pos) × Nat ➝ conj(Pos)
        _maxcons(e, c, max, n) ≡
            if vacio?(c) then  
                max
            else if nivel_i > n then 
                _maxcons(e, sinUno(c), Ag(pos_i, ∅), nivel_i)
            else if nivel_i = n then 
                _maxcons(e, sinUno(c), Ag(pos_i, max), n)
            else
                _maxcons(e, sinUno(c), max, n)
            fi 
            donde:
                pos_i ≡ dameUno(c)
                nivel_i ≡ nivel(e, pos_i)

        nivel: estr × pos ➝ Nat
        nivel(e, pos) ≡
            if def?(pos, conjCasas) then
                obtener(pos, conjCasas) + nivelesPorUnion(e, pos)
            else 
                maximo(obtener(pos, conjComercios) • significados(manhattan(pos, 3), conjCasas)) + nivelesPorUnion(e, pos)
            fi

        nivelesPorUnion: ^estr × pos ➝ Nat
        nivelesPorUnion(e, pos) ≡ 
            if def?(pos, e.casas) ∨ def?(pos, e.comercios) then
                0
            else
                hijoCorrecto.turnosDesdeUnion + nivelesPorUnion(hijoCorrecto.sc, pos)
            fi  
            donde:
                hijoCorrecto ≡ llegarAlHijoCorrecto(e.uniones, pos)

        llegarAlHijoCorrecto: secu(^hijo) × pos 
        llegarAlHijoCorrecto(s, p) ≡ // no puede quedar vacia, siempre se llama con un pos existente
            if def?(pos, unirCasas(h) ∨ def?(pos, unirComercios(h)) then 
                prim(s) 
            else 
                llegarAlHijoCorrecto(fin(s)) 
            fi 
            donde:
                h ≡ Ag(prim(s).sc, ∅)
        
        manhattan: Pos × Nat ➝ Conj(Pos)
        manhattan(p, dist) ≡ 
            if dist = 0 then 
                Ag(p, ∅)
            else 
                diagonal({p.x, p.y + dist}, {p.x + dist, p.y}) ⋃
                if p.x - dist ≥ 0 then diagonal({p.x, p.y + dist}, {p.x - dist, p.y}) else ∅ fi ⋃
                if p.y - dist ≥ 0 then diagonal({p.x, p.y - dist}, {p.x + dist, p.y}) else ∅ fi ⋃
                if p.x - dist ≥ 0 ∧ p.y - dist ≥ 0 then diagonal({p.x , p.y - dist}, {p.x - dist, p.y}) else ∅ fi ⋃
                manhattan(p, dist - 1)
            fi  

        diagonal: Pos p1 × Pos p2 × Nat n ➝ Conj(Pos)  {|p1.x - p2.x| = |p1.y - p2.y| ∧ 0 ≤ y ≤ |p2.y - p1.y|}
        diagonal(d, h, y) ≡ 
            if y = |h.y - d.y| then
                Ag(h,  ∅) 
            else 
                Ag(caminar(d, h, y), diagonal(d, h, y + 1)) 
            fi

        caminar: Pos × Pos × Nat ➝ Pos {|p1.x - p2.x| = |p1.y - p2.y| ∧ 0 ≤ y ≤ |p2.y - p1.y|}
        caminar(d, h, y) ≡
            if d.y ≤ h.y then  
                if d.x ≤ h.x then 
                    {d.x + y, d.y + y}
                else
                    {d.x - y, d.y + y}
                fi
            else
                if d.x ≤ h.x then 
                    {d.x + y, d.y - y}
                else
                    {d.x - y, d.y - y}
                fi
            fi 

        significados: conj(α) × dicc(α, β) ➝ secu(α)
        significados(c, d) ≡ 
            if vacio?(c) then 
                <>
            else if def?(dameUno(c), d) then 
                obtener(c, d) • significados(sinUno(c), d) 
            else
                significados(sinUno(c), d)
            fi 

        maximo: secu(Nat) a ➝ Nat   {long(a) > 0}
        maximo(s) ≡ if long(s) = 1 then prim(s) else max(prim(s), maximo(fin(s))) fi 

    abstraccion:
        abs: ^estr e ➝ SimCity {rep(e)}
        (∀ e: ^estr)
        abs(e) ≡ sc: SimCity |
            mapa(sc) =ob conjMapas ∧
            casas(sc) =obs nivelar(conjCasas) ∧
            comercios(sc) =obs nivelar(conjComercios) ∧
            popularidad(sc) =obs e.popularidad

            donde:
                conjUnidos ≡ unirPunteros(e.uniones)
                conjCasas ≡ unirCasas(ag(&e, conjUnidos)) 
                conjComercios ≡ unirComercios(ag(&e, conjUnidos))
                conjMapas  ≡ unirMapas(ag(&e, conjUnidos))

        nivelar: ^estr × dicc(Pos, Nat) ➝ dicc(Pos, Nat)
        nivelar(d) ≡ if vacio?(d) then vacio else definir(clave, nivel(e, clave), nivelar(e, borrar(clave, d))) fi     
        donde:
            clave ≡ dameUno(claves(d))

fin representacion
